% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/searchr_match_combinations.R
\name{schr_match_combinations}
\alias{schr_match_combinations}
\title{Performs matching of schr_tbl_chars() objects}
\usage{
schr_match_combinations(
  match_this,
  against_these,
  a_not_in_b_tolerance = 1,
  b_not_in_a_tolerance = 1
)
}
\arguments{
\item{match_this}{tabled characters; primary input with single row of a table created by /code{table_characters()}}

\item{against_these}{tabled characters; various possible names to match the first argument against, characters also must be tabled through /code{table_characters()}}

\item{a_not_in_b_tolerance}{number of non-required characters from your /code{match_this} input to find in matches, i.e. how many characters from A are not required to be in B e.g. "tori" has no characters that "tory girl" does not also have; any tolerance setting would match these; however, "tori" has one character that "tory" does not have, so matching these would require at least a tolerance of 1. Combinatorially, "tori" is a perfect match with "tior", "riot", etc, which means an /code{a_not_in_b_tolerance} of zero would find these matches}

\item{b_not_in_a_tolerance}{number of additional-non-matching characters (like wildcards) to allow in B that are not in A, e.g. "tori" differs from "torii" by b_not_in_a_tolerance of 1, and from "victoria" by b_not_in_a_tolerance of 4. Matching those names therefore requires at least those values.}
}
\description{
Matches any combination of letters from A against any combination of letters in B within specified tolerances. Function is case-sensitive.
}
\examples{
a_tbl <- schr_tbl_chars("eau leaf")
b_tbl <- schr_tbl_chars(c("eauleaf", "leafy", "eu leaf", "fael eau"))
schr_match_combinations(match_this = a_tbl, against_these = b_tbl)

}
